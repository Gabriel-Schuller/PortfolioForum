{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  let {\n    rootRef,\n    rootMargin,\n    disabled\n  } = _ref;\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const unobserve = (0, _react).useRef();\n  const [visible, setVisible] = (0, _react).useState(false);\n  const [root, setRoot] = (0, _react).useState(rootRef ? rootRef.current : null);\n  const setRef = (0, _react).useCallback(el => {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {\n        root,\n        rootMargin\n      });\n    }\n  }, [isDisabled, root, rootMargin, visible]);\n  (0, _react).useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = (0, _requestIdleCallback).requestIdleCallback(() => setVisible(true));\n        return () => (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n      }\n    }\n  }, [visible]);\n  (0, _react).useEffect(() => {\n    if (rootRef) setRoot(rootRef.current);\n  }, [rootRef]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      let index = idList.findIndex(obj => obj.root === id.root && obj.margin === id.margin);\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nconst observers = new Map();\nconst idList = [];\n\nfunction createObserver(options) {\n  const id = {\n    root: options.root || null,\n    margin: options.rootMargin || ''\n  };\n  let existing = idList.find(obj => obj.root === id.root && obj.margin === id.margin);\n  let instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n  } else {\n    instance = observers.get(id);\n    idList.push(id);\n  }\n\n  if (instance) {\n    return instance;\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id,\n    observer,\n    elements\n  });\n  return instance;\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","useIntersection","_react","require","_requestIdleCallback","hasIntersectionObserver","IntersectionObserver","rootRef","rootMargin","disabled","isDisabled","unobserve","useRef","visible","setVisible","useState","root","setRoot","current","setRef","useCallback","el","undefined","tagName","observe","isVisible","useEffect","idleCallback","requestIdleCallback","cancelIdleCallback","element","callback","options","id","observer","elements","createObserver","set","delete","size","disconnect","observers","index","idList","findIndex","obj","margin","splice","Map","existing","find","instance","get","push","entries","forEach","entry","target","isIntersecting","intersectionRatio"],"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/client/use-intersection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\nfunction useIntersection({ rootRef , rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const unobserve = (0, _react).useRef();\n    const [visible, setVisible] = (0, _react).useState(false);\n    const [root, setRoot] = (0, _react).useState(rootRef ? rootRef.current : null);\n    const setRef = (0, _react).useCallback((el)=>{\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, (isVisible)=>isVisible && setVisible(isVisible)\n            , {\n                root,\n                rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        root,\n        rootMargin,\n        visible\n    ]);\n    (0, _react).useEffect(()=>{\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true)\n                );\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback)\n                ;\n            }\n        }\n    }, [\n        visible\n    ]);\n    (0, _react).useEffect(()=>{\n        if (rootRef) setRoot(rootRef.current);\n    }, [\n        rootRef\n    ]);\n    return [\n        setRef,\n        visible\n    ];\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            let index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin\n            );\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    let existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin\n    );\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n    } else {\n        instance = observers.get(id);\n        idList.push(id);\n    }\n    if (instance) {\n        return instance;\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id,\n        observer,\n        elements\n    });\n    return instance;\n}\n\n"]},"metadata":{},"sourceType":"script"}