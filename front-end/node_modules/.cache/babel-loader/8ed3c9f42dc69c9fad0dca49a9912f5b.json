{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _parseUrl = require(\"./parse-url\");\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req === null || req === void 0 ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(groupKey => {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return (0, _pathToRegexp).compile(`/${value}`, {\n    validate: false\n  })(params).substr(1);\n}\n\nfunction prepareDestination(args) {\n  const query = Object.assign({}, args.query);\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  let escapedDestination = args.destination;\n\n  for (const param of Object.keys({ ...args.params,\n    ...query\n  })) {\n    escapedDestination = escapeSegment(escapedDestination, param);\n  }\n\n  const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n  const destQuery = parsedDestination.query;\n  const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n  const destHostname = unescapeSegments(parsedDestination.hostname || '');\n  const destPathParamKeys = [];\n  const destHostnameParamKeys = [];\n  (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n  (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n  const destParams = [];\n  destPathParamKeys.forEach(key => destParams.push(key.name));\n  destHostnameParamKeys.forEach(key => destParams.push(key.name));\n  const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n    validate: false\n  }); // update any params in query values\n\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map(value => compileNonPath(unescapeSegments(value), args.params));\n    } else {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(args.params).filter(name => name !== 'nextInternalLocale');\n\n  if (args.appendParamsToQuery && !paramKeys.some(key => destParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key];\n      }\n    }\n  }\n\n  let newUrl;\n\n  try {\n    newUrl = destPathCompiler(args.params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.hostname = destHostnameCompiler(args.params);\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = { ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    parsedDestination\n  };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\n\n\nfunction getSafeParamName(paramName) {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n\n  return newParamName;\n}\n\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\n\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, ':');\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","matchHas","compileNonPath","prepareDestination","_pathToRegexp","require","_escapeRegexp","_parseUrl","req","has","query","params","allMatch","every","hasItem","key","type","toLowerCase","headers","cookies","host","hostname","split","getSafeParamName","matcher","RegExp","matches","Array","isArray","slice","match","groups","keys","forEach","groupKey","includes","replace","compile","validate","substr","args","assign","__nextLocale","__nextDefaultLocale","escapedDestination","destination","param","escapeSegment","parsedDestination","parseUrl","destQuery","destPath","unescapeSegments","pathname","hash","destHostname","destPathParamKeys","destHostnameParamKeys","pathToRegexp","destParams","push","name","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","some","newUrl","search","err","message","Error","paramName","newParamName","i","length","charCode","charCodeAt","str","segmentName","escapeStringRegexp"],"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _parseUrl = require(\"./parse-url\");\nfunction matchHas(req, has, query) {\n    const params = {\n    };\n    const allMatch = has.every((hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case 'header':\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case 'cookie':\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case 'query':\n                {\n                    value = query[key];\n                    break;\n                }\n            case 'host':\n                {\n                    const { host  } = (req === null || req === void 0 ? void 0 : req.headers) || {\n                    };\n                    // remove port from host if present\n                    const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(`^${hasItem.value}$`);\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === 'host' && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    });\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(':')) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(`:${key}`)) {\n            value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathToRegexp).compile(`/${value}`, {\n        validate: false\n    })(params).substr(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({\n    }, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    let escapedDestination = args.destination;\n    for (const param of Object.keys({\n        ...args.params,\n        ...query\n    })){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n    const destHostname = unescapeSegments(parsedDestination.hostname || '');\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params)\n            );\n        } else {\n            destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale'\n    );\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key)\n    )) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split('#');\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = {\n        ...query,\n        ...parsedDestination.query\n    };\n    return {\n        newUrl,\n        parsedDestination\n    };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = '';\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, ':');\n}\n\n"]},"metadata":{},"sourceType":"script"}