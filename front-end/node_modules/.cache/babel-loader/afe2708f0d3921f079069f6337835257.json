{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\n\nclass UrlNode {\n  insert(urlPath) {\n    this._insert(urlPath.split('/').filter(Boolean), [], false);\n  }\n\n  smoosh() {\n    return this._smoosh();\n  }\n\n  _smoosh() {\n    let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n    const childrenPaths = [...this.children.keys()].sort();\n\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n    }\n\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n    }\n\n    const routes = childrenPaths.map(c => this.children.get(c)._smoosh(`${prefix}${c}/`)).reduce((prev, curr) => [...prev, ...curr], []);\n\n    if (this.slugName !== null) {\n      routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n\n      if (this.optionalRestSlugName != null) {\n        throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n      }\n\n      routes.unshift(r);\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n    }\n\n    return routes;\n  }\n\n  _insert(urlPaths, slugNames, isCatchAll) {\n    if (urlPaths.length === 0) {\n      this.placeholder = false;\n      return;\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`);\n    } // The next segment in the urlPaths list\n\n\n    let nextSegment = urlPaths[0]; // Check if the segment matches `[something]`\n\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1);\n      let isOptional = false;\n\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1);\n        isOptional = true;\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3);\n        isCatchAll = true;\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n      }\n\n      function handleSlug(previousSlug, nextSlug) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n          }\n        }\n\n        slugNames.forEach(slug => {\n          if (slug === nextSlug) {\n            throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n          }\n        });\n        slugNames.push(nextSlug);\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.optionalRestSlugName = segmentName; // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n\n          nextSegment = '[[...]]';\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n          }\n\n          handleSlug(this.restSlugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n          this.restSlugName = segmentName; // nextSegment is overwritten to [...] so that it can later be sorted specifically\n\n          nextSegment = '[...]';\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n        }\n\n        handleSlug(this.slugName, segmentName); // slugName is kept as it can only be one particular slugName\n\n        this.slugName = segmentName; // nextSegment is overwritten to [] so that it can later be sorted specifically\n\n        nextSegment = '[]';\n      }\n    } // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n\n\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode());\n    }\n\n    this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n  }\n\n  constructor() {\n    this.placeholder = true;\n    this.children = new Map();\n    this.slugName = null;\n    this.restSlugName = null;\n    this.optionalRestSlugName = null;\n  }\n\n}\n\nfunction getSortedRoutes(normalizedPages) {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode(); // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n\n  normalizedPages.forEach(pagePath => root.insert(pagePath)); // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n\n  return root.smoosh();\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","getSortedRoutes","UrlNode","insert","urlPath","_insert","split","filter","Boolean","smoosh","_smoosh","prefix","childrenPaths","children","keys","sort","slugName","splice","indexOf","restSlugName","optionalRestSlugName","routes","map","c","get","reduce","prev","curr","push","placeholder","r","slice","Error","unshift","urlPaths","slugNames","isCatchAll","length","nextSegment","startsWith","endsWith","segmentName","isOptional","substring","handleSlug","previousSlug","nextSlug","forEach","slug","replace","has","set","constructor","Map","normalizedPages","root","pagePath"],"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getSortedRoutes = getSortedRoutes;\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split('/').filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix = '/') {\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[]'), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[...]'), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(`${prefix}${c}/`)\n        ).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ]\n        , []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get('[]')._smoosh(`${prefix}[${this.slugName}]/`));\n        }\n        if (!this.placeholder) {\n            const r = prefix === '/' ? '/' : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error(`You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`);\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get('[...]')._smoosh(`${prefix}[...${this.restSlugName}]/`));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get('[[...]]')._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(`Catch-all must be the last part of the URL.`);\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith('...')) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n                throw new Error(`Segment names may not start or end with extra brackets ('${segmentName}').`);\n            }\n            if (segmentName.startsWith('.')) {\n                throw new Error(`Segment names may not start with erroneous periods ('${segmentName}').`);\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(`You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`);\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error(`You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`);\n                    }\n                    if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n                        throw new Error(`You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`);\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error(`You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`);\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = '[[...]]';\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error(`You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`);\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = '[...]';\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error(`Optional route parameters are not yet supported (\"${urlPaths[0]}\").`);\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = '[]';\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath)\n    );\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n}\n\n"]},"metadata":{},"sourceType":"script"}