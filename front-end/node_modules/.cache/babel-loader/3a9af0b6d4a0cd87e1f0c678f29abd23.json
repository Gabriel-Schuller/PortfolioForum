{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\n\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\n\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getParametrizedRoute(route) {\n  const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${escapeRegex(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${escapeRegex(segment)}`;\n      }\n    }).join('');\n    return {\n      parameterizedRoute,\n      namedParameterizedRoute,\n      groups,\n      routeKeys\n    };\n  }\n\n  return {\n    parameterizedRoute,\n    groups\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const result = getParametrizedRoute(normalizedRoute);\n\n  if ('routeKeys' in result) {\n    return {\n      re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n      groups: result.groups,\n      routeKeys: result.routeKeys,\n      namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`\n    };\n  }\n\n  return {\n    re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n    groups: result.groups\n  };\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","getParametrizedRoute","getRouteRegex","escapeRegex","str","replace","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","route","segments","split","groups","groupIndex","parameterizedRoute","map","segment","pos","join","window","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","fromCharCode","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","length","isNaN","parseInt","substr","normalizedRoute","result","re","RegExp","namedRegex"],"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/shared/lib/router/utils/route-regex.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex;\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str) {\n    return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\nfunction parseParameter(param) {\n    const optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n    const groups = {\n    };\n    let groupIndex = 1;\n    const parameterizedRoute = segments.map((segment)=>{\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n            const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n            groups[key] = {\n                pos: groupIndex++,\n                repeat,\n                optional\n            };\n            return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n        } else {\n            return `/${escapeRegex(segment)}`;\n        }\n    }).join('');\n    // dead code eliminate for browser since it's only needed\n    // while generating routes-manifest\n    if (typeof window === 'undefined') {\n        let routeKeyCharCode = 97;\n        let routeKeyCharLength = 1;\n        // builds a minimal routeKey using only a-z and minimal number of characters\n        const getSafeRouteKey = ()=>{\n            let routeKey = '';\n            for(let i = 0; i < routeKeyCharLength; i++){\n                routeKey += String.fromCharCode(routeKeyCharCode);\n                routeKeyCharCode++;\n                if (routeKeyCharCode > 122) {\n                    routeKeyCharLength++;\n                    routeKeyCharCode = 97;\n                }\n            }\n            return routeKey;\n        };\n        const routeKeys = {\n        };\n        let namedParameterizedRoute = segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, '');\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n            } else {\n                return `/${escapeRegex(segment)}`;\n            }\n        }).join('');\n        return {\n            parameterizedRoute,\n            namedParameterizedRoute,\n            groups,\n            routeKeys\n        };\n    }\n    return {\n        parameterizedRoute,\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const result = getParametrizedRoute(normalizedRoute);\n    if ('routeKeys' in result) {\n        return {\n            re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n            groups: result.groups,\n            routeKeys: result.routeKeys,\n            namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`\n        };\n    }\n    return {\n        re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n        groups: result.groups\n    };\n}\n\n"]},"metadata":{},"sourceType":"script"}