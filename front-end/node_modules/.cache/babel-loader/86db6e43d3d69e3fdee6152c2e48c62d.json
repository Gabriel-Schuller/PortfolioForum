{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nconst MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  let entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  let resolver;\n  const prom = new Promise(resolve => {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator() // eslint-disable-next-line no-sequences\n  .then(value => (resolver(value), value)).catch(err => {\n    map.delete(key);\n    throw err;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nconst canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise((res, rej) => {\n    const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n\n    if (document.querySelector(selector)) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = `prefetch`;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`))); // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\n\n\nlet devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise((resolve, reject) => {\n    let cancelled = false;\n    p.then(r => {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    }).catch(reject); // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n\n    if (process.env.NODE_ENV === 'development') {\n      (devBuildPromise || Promise.resolve()).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n          if (!cancelled) {\n            reject(err);\n          }\n        }, ms));\n      });\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n        if (!cancelled) {\n          reject(err);\n        }\n      }, ms));\n    }\n  });\n}\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  const onBuildManifest = new Promise(resolve => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getMiddlewareManifest() {\n  if (self.__MIDDLEWARE_MANIFEST) {\n    return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n  }\n\n  const onMiddlewareManifest = new Promise(resolve => {\n    const cb = self.__MIDDLEWARE_MANIFEST_CB;\n\n    self.__MIDDLEWARE_MANIFEST_CB = () => {\n      resolve(self.__MIDDLEWARE_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(manifest => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n    }\n\n    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));\n    return {\n      scripts: allFiles.filter(v => v.endsWith('.js')),\n      css: allFiles.filter(v => v.endsWith('.css'))\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  const entrypoints = new Map();\n  const loadedScripts = new Map();\n  const styleSheets = new Map();\n  const routes = new Map();\n\n  function maybeExecuteScript(src) {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom = loadedScripts.get(src);\n\n      if (prom) {\n        return prom;\n      } // Skip executing script if it's already in the DOM:\n\n\n      if (document.querySelector(`script[src^=\"${src}\"]`)) {\n        return Promise.resolve();\n      }\n\n      loadedScripts.set(src, prom = appendScript(src));\n      return prom;\n    } else {\n      return appendScript(src);\n    }\n  }\n\n  function fetchStyleSheet(href) {\n    let prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to load stylesheet: ${href}`);\n      }\n\n      return res.text().then(text => ({\n        href: href,\n        content: text\n      }));\n    }).catch(err => {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n\n    onEntrypoint(route, execute) {\n      (execute ? Promise.resolve().then(() => execute()).then(exports => ({\n        component: exports && exports.default || exports,\n        exports: exports\n      }), err => ({\n        error: err\n      })) : Promise.resolve(undefined)).then(input => {\n        const old = entrypoints.get(route);\n\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input);\n            old.resolve(input);\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input);\n          } else {\n            entrypoints.delete(route);\n          } // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n\n\n          routes.delete(route);\n        }\n      });\n    },\n\n    loadRoute(route, prefetch) {\n      return withFuture(route, routes, () => {\n        let devBuildPromiseResolve;\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise(resolve => {\n            devBuildPromiseResolve = resolve;\n          });\n        }\n\n        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(_ref => {\n          let {\n            scripts,\n            css\n          } = _ref;\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(res => {\n          return this.whenEntrypoint(route).then(entrypoint => ({\n            entrypoint,\n            styles: res[1]\n          }));\n        }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(_ref2 => {\n          let {\n            entrypoint,\n            styles\n          } = _ref2;\n          const res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        }).catch(err => {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        }).finally(() => {\n          return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n        });\n      });\n    },\n\n    prefetch(route) {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}));\n      }).catch( // swallow prefetch errors\n      () => {});\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["Object","defineProperty","exports","value","markAssetError","isAssetError","getClientBuildManifest","getMiddlewareManifest","createRouteLoader","_getAssetPathFromRoute","_interopRequireDefault","require","_requestIdleCallback","obj","__esModule","default","MS_MAX_IDLE_DELAY","withFuture","key","map","generator","entry","get","future","Promise","resolve","resolver","prom","set","then","catch","err","delete","hasPrefetch","link","document","createElement","window","MSInputMethodContext","documentMode","relList","supports","e","canPrefetch","prefetchViaDom","href","as","res","rej","selector","querySelector","rel","crossOrigin","process","env","__NEXT_CROSS_ORIGIN","onload","onerror","head","appendChild","ASSET_LOAD_ERROR","Symbol","appendScript","src","script","reject","Error","body","devBuildPromise","resolvePromiseWithTimeout","p","ms","cancelled","r","NODE_ENV","requestIdleCallback","setTimeout","self","__BUILD_MANIFEST","onBuildManifest","cb","__BUILD_MANIFEST_CB","__MIDDLEWARE_MANIFEST","onMiddlewareManifest","__MIDDLEWARE_MANIFEST_CB","getFilesForRoute","assetPrefix","route","scripts","encodeURI","css","manifest","allFiles","filter","v","endsWith","entrypoints","Map","loadedScripts","styleSheets","routes","maybeExecuteScript","fetchStyleSheet","fetch","ok","text","content","whenEntrypoint","onEntrypoint","execute","component","error","undefined","input","old","loadRoute","prefetch","devBuildPromiseResolve","all","has","entrypoint","styles","assign","finally","cn","navigator","connection","saveData","test","effectiveType","output"],"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/client/route-loader.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator()// eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)\n    ).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// detect IE11 since it supports prefetch but isn't detected\n        // with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((res, rej)=>{\n        const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = `prefetch`;\n        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {\n    });\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n        ;\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (process.env.NODE_ENV === 'development') {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms)\n                );\n            });\n        }\n        if (process.env.NODE_ENV !== 'development') {\n            (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                    if (!cancelled) {\n                        reject(err);\n                    }\n                }, ms)\n            );\n        }\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    const onMiddlewareManifest = new Promise((resolve)=>{\n        const cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = ()=>{\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (process.env.NODE_ENV === 'development') {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + encodeURI(entry)\n        );\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith('.js')\n            ),\n            css: allFiles.filter((v)=>v.endsWith('.css')\n            )\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (process.env.NODE_ENV !== 'development') {\n            let prom = loadedScripts.get(src);\n            if (prom) {\n                return prom;\n            }\n            // Skip executing script if it's already in the DOM:\n            if (document.querySelector(`script[src^=\"${src}\"]`)) {\n                return Promise.resolve();\n            }\n            loadedScripts.set(src, prom = appendScript(src));\n            return prom;\n        } else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to load stylesheet: ${href}`);\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                })\n            );\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()\n            ).then((exports)=>({\n                    component: exports && exports.default || exports,\n                    exports: exports\n                })\n            , (err)=>({\n                    error: err\n                })\n            ) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (process.env.NODE_ENV === 'development') {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts , css  })=>{\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        })\n                    );\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint , styles  })=>{\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script, 'script')\n                ) : [])\n            ).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{\n                    })\n                );\n            }).catch(// swallow prefetch errors\n            ()=>{\n            });\n        }\n    };\n}\n\n"]},"metadata":{},"sourceType":"script"}